// Player movements
ct Int PLAYER_MOVING_REST = 0
ct Int PLAYER_MOVING_RIGHT = 1
ct Int PLAYER_MOVING_LEFT = 2
ct Int PLAYER_MOVING_UP = 3
ct Int PLAYER_MOVING_DOWN = 4
ct Int PLAYER_CLIMBING = 5 
// Player speeds
ct Int PLAYER_SPEED_CLIMB_LADDER = 1
ct Int PLAYER_SPEED_WALK = 2
ct Int PLAYER_SPEED_RUN = 3
ct Int GROUND_SPEED = -5
// Player initial [x, y]
ct Int PLAYER_INITIAL_X = 32
ct Int PLAYER_INITIAL_Y = 128
// Player width and height
ct Int pw = 15
ct Int ph = 15
ct Int rw = pw - 1
ct Int rh = ph - 1
ct Int player_pw = 15
ct Int player_ph = 18
ct Int player_rw = player_pw - 1
ct Int player_rh = player_ph - 1
// Stamina
ct Int PLAYER_STARTING_STAMINA = 3
ct Int STAMINA_X = 8
ct Int STAMINA_Y = 24



// Player data struct
struct Player
    SS x
    SSF y
    SS w
    SSF h
    SS rw
    SSF rh
    SS center_x 
    SS center_y
    SF xspeed
    SF yspeed
    U movement
    AnimState anim_state
    U level_index
    Bool is_initialised
    SS camera_x
    U stamina
    AnimState stamina_anim_state
    Bool climbing
    Bool flying 


// Flying
vars /player_globals
    U flying_counter = 0
    Bool flying_enabled = true
ct U FLYING_LIMIT = 51 // (256 ~5[s] -> 1[s] ~51)
ct U FLYING_1_3_LIMIT = 17
ct U FLYING_2_3_LIMIT = 34
ct U FLYING_COOLDOWN = 153 // (256 ~5[s] -> 3[s] ~153)
ct U FLYING_1_3_COOLDOWN = 51
ct U FLYING_2_3_COOLDOWN = 102

// Sprites and animations
data /sprites
    // player metasprites
    [] sprite_player_rest_right
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $41, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $51, $01),
            Ms( 0,  0, $52, $01),
            Ms(-8,  8, $61, $01),
            Ms( 0,  8, $62, $01)
        )))
    [] sprite_player_rest_left
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $41, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $51, $01),
            Ms( 0,  0, $52, $01),
            Ms(-8,  8, $61, $01),
            Ms( 0,  8, $62, $01)
        )))
    [] sprite_player_right_1
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $41, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $51, $01),
            Ms( 0,  0, $52, $01),
            Ms(-8,  8, $61, $01),
            Ms( 0,  8, $62, $01)
        )))
    [] sprite_player_right_2
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $60, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $71, $01),
            Ms( 0,  0, $72, $01),
            Ms(-8,  8, $81, $01),
            Ms( 0,  8, $82, $01)

        )))
    [] sprite_player_right_3
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $70, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $71, $01),
            Ms( 0,  0, $72, $01),
            Ms(-8,  8, $91, $01),
            Ms( 0,  8, $92, $01)

        )))
    [] sprite_player_left_1
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $41, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $51, $01),
            Ms( 0,  0, $52, $01),
            Ms(-8,  8, $61, $01),
            Ms( 0,  8, $62, $01)

        )))
    [] sprite_player_left_2
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $60, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $71, $01),
            Ms( 0,  0, $72, $01),
            Ms(-8,  8, $81, $01),
            Ms( 0,  8, $82, $01)

        )))
    [] sprite_player_left_3
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $70, $01),
            Ms( 0, -8, $42, $01),
            Ms(-8,  0, $71, $01),
            Ms( 0,  0, $72, $01),
            Ms(-8,  8, $91, $01),
            Ms( 0,  8, $92, $01)

        )))
    // Animations
    [] player_animation_rest_right
        (make_anim(Fs{}(
            Fs(20,   @sprite_player_rest_right)
        )))
    [] player_animation_rest_left
        (make_anim(Fs{}(
            Fs(20,   @sprite_player_rest_left)
        )))
    [] player_animation_right
        (make_anim(Fs{}(
            Fs(10,   @sprite_player_right_1),
            Fs(10,   @sprite_player_right_2),
            Fs(10,   @sprite_player_right_3)
        )))
    [] player_animation_left
        (make_anim(Fs{}(
            Fs(10,   @sprite_player_left_1),
            Fs(10,   @sprite_player_left_2),
            Fs(10,   @sprite_player_left_3)
        )))
    // Stamina sprites
    [] sprite_stamina_full
        (make_metasprite(0, Ms{}(
                Ms(-8,  0, $5D, $00),
                Ms( 0,  0, $5E, $00),
                Ms( 8,  0, $5F, $00)
        )))
    [] sprite_stamina_2_3
        (make_metasprite(0, Ms{}(
                Ms(-8,  0, $5D, $00),
                Ms( 0,  0, $5E, $00),
                Ms( 8,  0, $4F, $00)
        )))
    [] sprite_stamina_1_3
        (make_metasprite(0, Ms{}(
                Ms(-8,  0, $5D, $00),
                Ms( 0,  0, $4E, $00),
                Ms( 8,  0, $4F, $00)
        )))
    [] sprite_stamina_empty
        (make_metasprite(0, Ms{}(
                Ms(-8,  0, $4D, $00),
                Ms( 0,  0, $4E, $00),
                Ms( 8,  0, $4F, $00)
        )))
    // Stamina animations
    [] stamina_animation_full
        (make_anim(Fs{}(
            Fs(20,   @sprite_stamina_full)
        )))
    [] stamina_animation_2_3
        (make_anim(Fs{}(
            Fs(20,   @sprite_stamina_2_3)
        )))
    [] stamina_animation_1_3
        (make_anim(Fs{}(
            Fs(20,   @sprite_stamina_1_3)
        )))
    [] stamina_animation_empty
        (make_anim(Fs{}(
            Fs(20,   @sprite_stamina_empty)
        )))


// Helper functions
fn make_player() Player
    Player p = Player()
    p.x = PLAYER_INITIAL_X
    p.y = PLAYER_INITIAL_Y
    p.w = player_pw
    p.h = player_ph
    p.rw = player_rw
    p.rh = player_rh
    p.movement = PLAYER_MOVING_REST
    p.anim_state = make_anim_state(@player_animation_rest_right)
    p.level_index = FIRST_LEVEL_INDEX
    p.is_initialised = true
    p.stamina = PLAYER_STARTING_STAMINA
    p.stamina_anim_state = make_anim_state(@stamina_animation_full)
    return p

fn update_camera()
    // Update camera:
    ct Int window = 112
    if p.center_x - p.camera_x < window
        p.camera_x = p.center_x - window
    else if p.center_x - p.camera_x > 256 - window
        p.camera_x = p.center_x - (256 - window)
    p.camera_x = min(max(0, p.camera_x), (SS(current_level_width) << 4) - 256)

fn handle_collisions()
    // Check for coin/exit collisions:
    switch collision_at(UU(p.center_x), UU(p.center_y)) 
        case C_COIN
            destroy(UU(p.center_x), UU(p.center_y))
            break
        case C_EXIT
            current_level_index += 1
            if current_level_index > LAST_LEVEL_INDEX
                current_level_index = FIRST_LEVEL_INDEX
            // Update player
            p.level_index = current_level_index
            p.x = PLAYER_INITIAL_X
            p.y = PLAYER_INITIAL_Y
            nmi
            goto mode play_level(current_level_index)
            : preserves /game
        case C_KEY
                keys[level_to_key_mapping[current_level_index]] = true
                key_x[current_level_index] = U(p.center_x)
                key_y[current_level_index] = U(p.center_y)
                destroy(UU(p.center_x), UU(p.center_y))
                break

fn player_resting()
    // Resting
    if !pads[0].held && p.movement != PLAYER_MOVING_REST
        switch p.movement
            case PLAYER_MOVING_RIGHT
                p.anim_state = make_anim_state(@player_animation_rest_right)
                break
            case PLAYER_MOVING_LEFT
                p.anim_state = make_anim_state(@player_animation_rest_left)
                break
        p.movement = PLAYER_MOVING_REST

fn walk()
    // Update x-position:
    SS speed = PLAYER_SPEED_WALK
    if pads[0].held & BUTTON_B 
        speed = PLAYER_SPEED_RUN
    if pads[0].held & BUTTON_LEFT
        if collision_at(UU(p.x - speed), UU(p.y)) != C_WALL && collision_at(UU(p.x - speed), UU(p.y + p.rh)) != C_WALL && !door_collision_at(current_level_index, UU(p.x - speed), UU(p.y)) && !door_collision_at(current_level_index, UU(p.x - speed), UU(p.y + p.rh))
            if collision_at(UU(p.x - SS(p.h)), UU(p.y)) == C_CEILING_SCALE
                p.x -= PLAYER_SPEED_CLIMB_LADDER
                if p.movement != PLAYER_CLIMBING
                    p.movement = PLAYER_CLIMBING
                    // p.anim_state = make_anim_state(@player_animation_climb_ladder)
                    p.anim_state = make_anim_state(@player_animation_left)        // ToDo: create animation
            else
                if p.movement != PLAYER_MOVING_LEFT
                    p.movement = PLAYER_MOVING_LEFT     
                    p.anim_state = make_anim_state(@player_animation_left)
            p.x -= speed
    if pads[0].held & BUTTON_RIGHT
        if collision_at(UU(p.x + p.rw + speed), UU(p.y)) != C_WALL && collision_at(UU(p.x + p.rw + speed), UU(p.y + p.rh)) != C_WALL && !door_collision_at(current_level_index, UU(p.x + p.rw + speed), UU(p.y)) && !door_collision_at(current_level_index, UU(p.x + p.rw + speed), UU(p.y + p.rh))
            if collision_at(UU(p.x + SS(p.h)), UU(p.y)) == C_CEILING_SCALE
                p.x += PLAYER_SPEED_CLIMB_LADDER
                if p.movement != PLAYER_CLIMBING
                    p.movement = PLAYER_CLIMBING
                    // p.anim_state = make_anim_state(@player_animation_climb_ladder)
                    p.anim_state = make_anim_state(@player_animation_right)     // ToDo: create animation
            else
                if p.movement != PLAYER_MOVING_RIGHT
                    p.movement = PLAYER_MOVING_RIGHT
                    p.anim_state = make_anim_state(@player_animation_right)
            p.x += speed
    
    // Ground
    if (collision_at(UU(p.center_x), UU(p.center_y + PLAYER_SPEED_WALK)) != C_LADDER && collision_at(UU(p.center_x), UU(p.center_y + SS(p.h) - PLAYER_SPEED_WALK)) != C_LADDER)
        if collision_at(UU(p.x + 0), UU(p.y + p.h)) == C_WALL || collision_at(UU(p.x + p.rw), UU(p.y + p.h)) == C_WALL  || door_collision_at(current_level_index, UU(p.x + 0), UU(p.y + p.h)) || door_collision_at(current_level_index, UU(p.x + p.rw), UU(p.y + p.h))
            if pads[0].pressed & BUTTON_A
                p.yspeed = GROUND_SPEED

        
        // Update y-position:
        // Climbing horizontally, no gravity
        U collision = collision_at(UU(p.x), UU(p.y))
        if collision == C_CEILING_SCALE || collision == C_LADDER
            p.climbing = true
        else
            p.climbing = false
        // Normal horizontal movement
        if !p.climbing
            SSF new_y = p.y + SSF(p.yspeed)
            p.yspeed += 0.25
            if p.yspeed > 0
                if collision_at(UU(p.x + 0), UU(new_y + p.rh)) == C_WALL || collision_at(UU(p.x + p.rw), UU(new_y + p.rh)) == C_WALL || door_collision_at(current_level_index, UU(p.x + 0), UU(new_y + p.rh)) ||door_collision_at(current_level_index, UU(p.x + p.rw), UU(new_y + p.rh))
                    p.yspeed = 0
                    p.y = ((new_y + p.rh) & SSF(~%1111)) - SSF(p.h)
                else
                    p.y = new_y
            else
                if collision_at(UU(p.x + 0), UU(new_y)) == C_WALL || collision_at(UU(p.x + p.rw), UU(new_y)) == C_WALL || door_collision_at(current_level_index, UU(p.x + 0), UU(new_y)) ||door_collision_at(current_level_index, UU(p.x + p.rw), UU(new_y))
                    p.yspeed = 0
                    p.y = (p.y & SSF(~%1111))
                else
                    p.y = new_y
    // Ladder
    else
        climb()

fn climb()
        if pads[0].held & BUTTON_UP
            if p.movement != PLAYER_CLIMBING
                p.movement = PLAYER_CLIMBING
            if collision_at(UU(p.x), UU(p.y - p.h - PLAYER_SPEED_CLIMB_LADDER)) != C_WALL && !door_collision_at(current_level_index, UU(p.x), UU(p.y - p.h - PLAYER_SPEED_CLIMB_LADDER))
                p.y -= PLAYER_SPEED_CLIMB_LADDER
                // p.anim_state = make_anim_state(@player_animation_climb_ladder)       // ToDo: create animation
                p.anim_state = make_anim_state(@player_animation_right)
        if pads[0].held & BUTTON_DOWN
            if p.movement != PLAYER_CLIMBING
                p.movement = PLAYER_CLIMBING
            if collision_at(UU(p.x), UU(p.y + p.h + PLAYER_SPEED_CLIMB_LADDER)) != C_WALL && !door_collision_at(current_level_index, UU(p.x), UU(p.y + p.h + PLAYER_SPEED_CLIMB_LADDER))
                p.y += PLAYER_SPEED_CLIMB_LADDER
                // p.anim_state = make_anim_state(@player_animation_climb_ladder)       // ToDo: create animatio
                p.anim_state = make_anim_state(@player_animation_left)

fn fly()
    // Countdown of flying capacity
    flying_counter += 1
    if flying_counter == FLYING_1_3_LIMIT
        p.stamina = 2
        p.stamina_anim_state = make_anim_state(@stamina_animation_2_3)
    if flying_counter == FLYING_2_3_LIMIT
        p.stamina_anim_state = make_anim_state(@stamina_animation_1_3)
        p.stamina = 1
    if flying_counter == FLYING_LIMIT
        p.stamina_anim_state = make_anim_state(@stamina_animation_empty)
        p.stamina = 0
        flying_counter = 0
        flying_enabled = false
    SS speed = PLAYER_SPEED_WALK
    if pads[0].held & BUTTON_RIGHT
        if collision_at(UU(p.x + p.rw + speed), UU(p.y)) != C_WALL && collision_at(UU(p.x + p.rw + speed), UU(p.y + p.rh)) != C_WALL && !door_collision_at(current_level_index, UU(p.x + p.rw + speed), UU(p.y)) && !door_collision_at(current_level_index, UU(p.x + p.rw + speed), UU(p.y + p.rh))
            if p.movement != PLAYER_MOVING_RIGHT
                p.movement = PLAYER_MOVING_RIGHT
                p.anim_state = make_anim_state(@player_animation_right)
            p.x += speed
    if pads[0].held & BUTTON_LEFT
        if collision_at(UU(p.x - speed), UU(p.y)) != C_WALL && collision_at(UU(p.x - speed), UU(p.y + p.rh)) != C_WALL && !door_collision_at(current_level_index, UU(p.x - speed), UU(p.y)) && !door_collision_at(current_level_index, UU(p.x - speed), UU(p.y + p.rh))
            if p.movement != PLAYER_MOVING_LEFT
                p.movement = PLAYER_MOVING_LEFT
                p.anim_state = make_anim_state(@player_animation_left)
            p.x -= speed
    if pads[0].held & BUTTON_UP
        if p.y >= 0
            if collision_at(UU(p.x), UU(p.y)) != C_WALL && !door_collision_at(current_level_index, UU(p.x), UU(p.y))
                if p.movement == PLAYER_MOVING_RIGHT
                    p.anim_state = make_anim_state(@player_animation_right)
                if p.movement == PLAYER_MOVING_LEFT
                    p.anim_state = make_anim_state(@player_animation_left)
                p.y -= speed
    if pads[0].held & BUTTON_DOWN
        SSF half_ph = p.h >> 1
        if collision_at(UU(p.x), UU(p.y)) != C_WALL && !door_collision_at(current_level_index, UU(p.x), UU(p.y))
            if p.movement == PLAYER_MOVING_RIGHT
                p.anim_state = make_anim_state(@player_animation_right)
            if p.movement == PLAYER_MOVING_LEFT
                p.anim_state = make_anim_state(@player_animation_left)
            p.y += speed
    // Get tired of flying
    //p.y += 0.1 * flying_counter

fn move_player()
    p.center_x = SS(p.x) + (p.w >> 1)
    p.center_y = SS(p.y) + SS(p.h >> 1)
    p.climbing = false
    p.flying = false

    // Can player fly?
    p.flying = false
    if pads[0].held & BUTTON_B
        p.flying = true
    
    
    // Fly baby!
    if p.flying && flying_enabled
        fly()
    // Flying enabled but not flying
    if !p.flying && flying_enabled
        if flying_counter > 0 && flying_counter < 153
            flying_counter -= 1
        else
            flying_enabled = true
    
    // No flying baby
    if !flying_enabled
        p.flying = false
        flying_counter += 1
        if flying_counter == FLYING_1_3_COOLDOWN
            p.stamina_anim_state = make_anim_state(@stamina_animation_1_3)
            p.stamina = 1
        if flying_counter == FLYING_2_3_COOLDOWN
            p.stamina_anim_state = make_anim_state(@stamina_animation_2_3)
            p.stamina = 2
        if flying_counter == FLYING_COOLDOWN
            p.stamina_anim_state = make_anim_state(@stamina_animation_full)
            p.stamina = 3
            flying_enabled = true
            flying_counter = 0
    // Normal movement
    if !p.flying
        walk()

// Main function to call
fn update_player()

    if !is_game_paused
        move_player()
        player_resting()
        handle_collisions()
        update_camera()

    