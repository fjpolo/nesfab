/*
 * Copyright (c) 2023, fjpolo@gmail.com
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

ct Int PLAYER_MOVING_REST = 0
ct Int PLAYER_MOVING_RIGHT = 1
ct Int PLAYER_MOVING_LEFT = 2
ct Int PLAYER_SPEED = 2

data /sprites
    // Here's where we define our metasprite, comprised of four 8x8 tiles:
    [] sprite_lucifer_rest
        (make_metasprite(0, Ms{}(
            Ms(-8,-8, $00, $00),
            Ms(0, -8, $00, $00),
            Ms(-8, 0, $50, $00),
            Ms( 0, 0, $51, $00),
            Ms(-8, 8, $52, $00),
            Ms( 0, 8, $53, $00)
        )))
    [] sprite_lucifer_right_1
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $41, $00),
            Ms( 0, -8, $42, $00),
            Ms(-8,  0, $43, $00),
            Ms( 0,  0, $44, $00),
            Ms(-8,  8, $45, $00),
            Ms( 0,  8, $46, $00)
        )))
    [] sprite_lucifer_right_2
        (make_metasprite(0, Ms{}(
            Ms(-8, -8, $41, $00),
            Ms( 0, -8, $47, $00),
            Ms(-8,  0, $43, $00),
            Ms( 0,  0, $44, $00),
            Ms(-8,  8, $45, $00),
            Ms( 0,  8, $46, $00)
        )))
    [] sprite_lucifer_left_1
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $41, $00),
            Ms( 0, -8, $42, $00),
            Ms(-8,  0, $43, $00),
            Ms( 0,  0, $44, $00),
            Ms(-8,  8, $45, $00),
            Ms( 0,  8, $46, $00)
        )))
    [] sprite_lucifer_left_2
        (make_metasprite(ATTR_H_FLIP, Ms{}(
            Ms(-8, -8, $41, $00),
            Ms( 0, -8, $47, $00),
            Ms(-8,  0, $43, $00),
            Ms( 0,  0, $44, $00),
            Ms(-8,  8, $45, $00),
            Ms( 0,  8, $46, $00)
        )))

    // Animations
    [] lucifer_animation_rest
        (make_anim(Fs{}(
            Fs(20,   @sprite_lucifer_rest)
        )))
    [] lucifer_animation_right
        (make_anim(Fs{}(
            Fs(20,   @sprite_lucifer_right_1),
            Fs(20,   @sprite_lucifer_right_2)
        )))
    [] lucifer_animation_left
        (make_anim(Fs{}(
            Fs(20,   @sprite_lucifer_left_1),
            Fs(20,   @sprite_lucifer_left_2)
        )))

// Player width and height:
ct Int pw = 15
ct Int ph = 23
ct Int rw = pw - 1
ct Int rh = ph - 1

// Player data:
struct Player
    SS x
    SSF y
    SF xspeed
    SF yspeed
    U attr
    U movemenent
    AnimState anim_state

vars /game
    // Game variables
    Player p = make_player(64, 64)
    SS camera_x = 0

fn make_player(SS x, SS y) Player
    Player p = Player()
    p.x = x
    p.y = SSF(y)
    p.movemenent = PLAYER_MOVING_REST
    p.anim_state = AnimState()
    return p

nmi game_nmi()
    ppu_upload_scroll()
    ppu_reset_scroll(camera_x.a, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON | (camera_x.b & 1))
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    ppu_upload_oam_poll_pads(0)

mode main()
    p.anim_state = make_anim_state(@lucifer_animation_rest)
    goto mode play_level(current_level_index)
    : preserves

mode play_level(U level_index)
: nmi game_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)
    hide_oam(0)
    load_level(levels[level_index])
    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        nmi
        update_pads()
        update_player()
        update_sprites()
        update_scroll()

fn update_player()
    // Update x-position:
    if pads[0].held & BUTTON_LEFT
        if collision_at(UU(p.x - 2), UU(p.y)) != C_WALL && collision_at(UU(p.x - PLAYER_SPEED), UU(p.y + rh)) != C_WALL
            if p.movemenent != PLAYER_MOVING_LEFT
                p.movemenent = PLAYER_MOVING_LEFT
                p.anim_state = make_anim_state(@lucifer_animation_left)
            p.x -= PLAYER_SPEED
            if pads[0].held & BUTTON_B
                p.x -= PLAYER_SPEED

    if pads[0].held & BUTTON_RIGHT
        if collision_at(UU(p.x + rw + 2), UU(p.y)) != C_WALL && collision_at(UU(p.x + rw + PLAYER_SPEED), UU(p.y + rh)) != C_WALL
            if p.movemenent != BUTTON_RIGHT
                p.movemenent = BUTTON_RIGHT
                p.anim_state = make_anim_state(@lucifer_animation_right)
            p.x += PLAYER_SPEED
            if pads[0].held & BUTTON_B
                p.x += PLAYER_SPEED
    
    // Ground
    if collision_at(UU(p.x + 0), UU(p.y + ph)) == C_WALL || collision_at(UU(p.x + rw), UU(p.y + ph)) == C_WALL
        if pads[0].pressed & BUTTON_A
            p.yspeed = -5

    // Update y-position:
    SSF new_y = p.y + SSF(p.yspeed)
    p.yspeed += 0.25
    if p.yspeed > 0
        if collision_at(UU(p.x + 0), UU(new_y + rh)) == C_WALL || collision_at(UU(p.x + rw), UU(new_y + rh)) == C_WALL
            p.yspeed = 0
            p.y = ((new_y + rh) & SSF(~%1111)) - ph
        else
            p.y = new_y
    else
        if collision_at(UU(p.x + 0), UU(new_y)) == C_WALL || collision_at(UU(p.x + rw), UU(new_y)) == C_WALL
            p.yspeed = 0
            p.y = (p.y & SSF(~%1111))
        else
            p.y = new_y

    // // Resting
    // if !pads[0].held && p.movemenent != PLAYER_MOVING_REST
    //     p.movemenent = PLAYER_MOVING_REST
    //     p.anim_state = make_anim_state(@lucifer_animation_rest)

    // Check for coin collisions:
    SS center_x = SS(p.x) + (pw >> 1)
    SS center_y = SS(p.y) + (ph >> 1)
    switch collision_at(UU(center_x), UU(center_y)) 
        case C_COIN
            destroy(UU(center_x), UU(center_y))
            break
        // case C_EXIT
        //     current_level_index += 1
        //     if current_level_index >= len(levels)
        //         current_level_index = 0
        //     nmi
        //     goto mode play_level(current_level_index)
        //     : preserves /game
    // Select
    if pads[0].held & BUTTON_SELECT
        current_level_index += 1
        if current_level_index >= len(levels)
            current_level_index = 0
        nmi
        goto mode play_level(current_level_index)
        : preserves /game

    // Update camera:
    ct Int window = 112
    if center_x - camera_x < window
        camera_x = center_x - window
    else if center_x - camera_x > 256 - window
        camera_x = center_x - (256 - window)
    camera_x = min(max(0, camera_x), (SS(current_level_width) << 4) - 256)


fn update_sprites()
    // Our stack index into OAM:
    U o = 0

    o = push_oam_anim(o, SS(p.x) - camera_x + 8, SS(p.y) + 6, p.anim_state)

    hide_oam(o)

    // Tick animation
    p.anim_state = tick_anim(p.anim_state, true)

