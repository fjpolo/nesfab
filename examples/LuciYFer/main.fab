/*
 * Copyright (c) 2023, fjpolo@gmail.com
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// Button constants
ct Int SELECT_BUTTON_DEBOUNCE_FRAMES = 7
ct Int START_BUTTON_DEBOUNCE_FRAMES = 7

// Game states
ct Int GAME_STATE_START = 0
ct Int GAME_STATE_STORY = 1
ct Int GAME_STATE_PLAY = 2
ct Int GAME_STATE_PAUSE = 3
ct Int GAME_STATE_WIN = 4
ct Int GAME_STATE_GAME_OVER = 5

// Controller data
vars /controller
    Bool is_start_pressed_past = false
    Bool is_start_pressed = false
    U start_counter = 0
    Bool is_select_pressed_past = false
    Bool is_select_pressed = false
    U select_counter = 0


// Game data
vars /game
    Player p =  Player()
    SS camera_x = 0
    U current_player = CURRENT_PLAYER_LUCI
    U game_state = GAME_STATE_STORY

nmi game_nmi()

    if game_state == GAME_STATE_STORY
        if ready && writing == WRITING_READY
            // Upload the decompressed character:
            {PPUSTATUS}()
            {PPUADDR}(cur_addr.b)
            {PPUADDR}(cur_addr.a)
            {PPUDATA}(char)
            cur_addr += 1
            writing = WRITING_WAIT
            {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)


        {PPUSCROLL}(0)
        {PPUSCROLL}(0)
        {PPUMASK}(PPUMASK_BG_ON)

    ppu_upload_scroll()
    ppu_reset_scroll(camera_x.a, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON | (camera_x.b & 1))
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    ppu_upload_oam_poll_pads(0)

    if pads[0].held & BUTTON_SELECT
        is_select_pressed_past = true
        select_counter += 1
        if select_counter == SELECT_BUTTON_DEBOUNCE_FRAMES
            select_counter = 0
            is_select_pressed = true
    else
        select_counter = 0

    // Start pressed?
    if pads[0].held & BUTTON_START
        is_start_pressed_past = true
        start_counter += 1
        if start_counter == START_BUTTON_DEBOUNCE_FRAMES
            start_counter = 0
            is_start_pressed = true
    else
        start_counter = 0


mode main()
    {PPUCTRL}(0)
    {PPUMASK}(0)
    hide_oam(0)    

    load_level(levels[current_level_index]) 
    
    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        switch game_state
            case GAME_STATE_START
                goto mode start_screen(current_level_index)
                : preserves
                break
            case GAME_STATE_STORY
                goto mode story_screen(current_level_index)
                : preserves
                break
            default
                goto mode play_level(current_level_index)
                : preserves
                break




mode play_level(U level_index)
: nmi game_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)
    hide_oam(0)
    // Avoid START and STORY levels
    if current_level_index== 0 || current_level_index == 1
        current_level_index = 2
    load_level(levels[level_index]) 

    // Animation -  Rest state
    switch current_player
        case CURRENT_PLAYER_LUCI
            p = make_player_luci()
            break
        case CURRENT_PLAYER_FER
            p = make_player_fer()
            break

    {PPUCTRL}(PPUCTRL_NMI_ON)
    
    while true
        nmi
        update_pads()
        update_player()
        update_sprites()
        update_scroll()

fn update_sprites()
    // Our stack index into OAM:
    U o = 0

    o = push_oam_anim(o, SS(p.x) - camera_x + 8, SS(p.y) + 6, p.anim_state)

    hide_oam(o)

    // Tick animation
    p.anim_state = tick_anim(p.anim_state, true)
