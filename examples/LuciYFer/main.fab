/*
 * Copyright (c) 2023, fjpolo@gmail.com
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// Button constants
ct Int SELECT_BUTTON_DEBOUNCE_FRAMES = 7
ct Int START_BUTTON_DEBOUNCE_FRAMES = 7

// Game states
ct Int GAME_STATE_START = 0
ct Int GAME_STATE_STORY = 1
ct Int GAME_STATE_PLAY = 2
ct Int GAME_STATE_PAUSE = 3
ct Int GAME_STATE_WIN = 4
ct Int GAME_STATE_GAME_OVER = 5

// Controller data
vars /controller
    Bool is_start_pressed_past = false
    Bool is_start_pressed = false
    U start_counter = 0
    Bool is_select_pressed_past = false
    Bool is_select_pressed = false
    U select_counter = 0


// Game data
vars /game
    Player luci =  Player()
    Player fer =  Player()
    Player p =  Player()
    U current_player = CURRENT_PLAYER_LUCI
    U game_state = GAME_STATE_STORY
    U chr_counter = 0
    U chr_bank = 0

// NMI
nmi game_nmi()
    // Switch CHR ROM banks for animated tiles
    if current_level_index > 1
        chr_counter += 1
        if chr_counter == 30
            chr_counter = 0
            // Change CHR ROM Bank on the fly
            // load_chrrom_bank(levels[current_level_index], chr_bank)
    // Story screen
    if game_state == GAME_STATE_STORY
        if ready && writing == WRITING_READY
            // Upload the decompressed character:
            {PPUSTATUS}()
            {PPUADDR}(cur_addr.b)
            {PPUADDR}(cur_addr.a)
            {PPUDATA}(char)
            cur_addr += 1
            writing = WRITING_WAIT
            {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
        {PPUSCROLL}(0)
        {PPUSCROLL}(0)
        {PPUMASK}(PPUMASK_BG_ON)

    ppu_upload_scroll()
    ppu_reset_scroll(p.camera_x.a, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON | (p.camera_x.b & 1))
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    ppu_upload_oam_poll_pads(0)

    // Select pressed?
    if pads[0].held & BUTTON_SELECT
        is_select_pressed_past = true
        select_counter += 1
        if select_counter == SELECT_BUTTON_DEBOUNCE_FRAMES
            select_counter = 0
            is_select_pressed = true
    else
        select_counter = 0

    // Start pressed?
    if pads[0].held & BUTTON_START
        is_start_pressed_past = true
        start_counter += 1
        if start_counter == START_BUTTON_DEBOUNCE_FRAMES
            start_counter = 0
            is_start_pressed = true
    else
        start_counter = 0

// MAIN
mode main()
    {PPUCTRL}(0)
    {PPUMASK}(0)
    hide_oam(0)    

    // Load level
    load_level(levels[current_level_index]) 
    
    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        switch game_state
            case GAME_STATE_START
                goto mode start_screen(current_level_index)
                : preserves
                break
            case GAME_STATE_STORY
                goto mode story_screen(current_level_index)
                : preserves
                break
            default
                goto mode play_level(current_level_index)
                : preserves
                break




mode play_level(U level_index)
: nmi game_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)
    hide_oam(0)
    // Avoid START and STORY levels
    if current_level_index== 0 || current_level_index == 1
        current_level_index = 2
    load_level(levels[level_index]) 

    // Animation -  Rest state
    if !luci.is_initialised
        luci = make_player_luci()
    if !fer.is_initialised
        fer = make_player_fer()
    switch current_player
        case CURRENT_PLAYER_LUCI
            p = restore_player(luci)
            break
        case CURRENT_PLAYER_FER
            p = restore_player(fer)
            break

    {PPUCTRL}(PPUCTRL_NMI_ON)
    
    while true
        nmi
        update_pads()
        update_player()
        update_sprites()
        update_scroll()

        if chr_counter == 0
            if chr_bank == 0
                chr_bank = 1
            else
                chr_bank = 0
            // Change CHR ROM Bank on the fly
            // // {PPUCTRL}(0)
            // // {PPUMASK}(0)
            // // hide_oam(0)
            // load_chrrom_bank(levels[current_level_index], chr_bank)
            // // {PPUCTRL}(PPUCTRL_NMI_ON)

fn update_sprites()
    // Our stack index into OAM:
    U o = 0

    o = push_oam_anim(o, SS(p.x) - p.camera_x + 8, SS(p.y) + 6, p.anim_state)
    // Luci Y Fer?
    if luci.level_index == fer.level_index && current_player != CURRENT_PLAYER_LUCIFER
        // Draw also second character
        switch current_player
            case CURRENT_PLAYER_LUCI
                o = push_oam_anim(o, SS(fer.x) - p.camera_x + 8, SS(fer.y) + 6, fer.anim_state)
                break
            case CURRENT_PLAYER_FER
                o = push_oam_anim(o, SS(luci.x) - p.camera_x + 8, SS(luci.y) + 6, luci.anim_state)
                break

    hide_oam(o)

    // Tick animation
    p.anim_state = tick_anim(p.anim_state, true)

fn update_chrrom_bank()
